{
  parserClass ="com.blamejared.zencodeplugin.parser.ZenCodeParser"
  parserUtilClass="com.blamejared.zencodeplugin.parser.ZenCodeParserUtil"
  psiImplUtilClass="com.blamejared.zencodeplugin.psi.ZenCodePsiImplUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="ZenCode"
  psiImplClassSuffix="Impl"
  psiPackage="com.blamejared.zencodeplugin.psi"
  psiImplPackage="com.blamejared.zencodeplugin.psi.impl"

  //Generated
  elementTypeHolderClass="com.blamejared.zencodeplugin.psi.ZenCodeTypes"

  elementTypeClass="com.blamejared.zencodeplugin.psi.ZenCodeElementType"
  tokenTypeClass="com.blamejared.zencodeplugin.psi.ZenCodeTokenType"

  tokens=[
    T_COMMENT_SCRIPT='regexp:#[^\n]*[\n\\e]'
    T_COMMENT_SINGLELINE='regexp://[^\n]*'
    T_COMMENT_MULTILINE='regexp:/\*([^\\*]|(\\*+([^\\*/])))*\*+/'

    T_WHITESPACE_SPACE=' '
    T_WHITESPACE_TAB='\t'
    T_WHITESPACE_NEWLINE='\n'
    T_WHITESPACE_CARRIAGE_RETURN='\r'

    T_IDENTIFIER='regexp:@?[a-zA-Z_][a-zA-Z_0-9]*'
    T_LOCAL_IDENTIFIER='regexp:\$[a-zA-Z_][a-zA-Z_0-9]*'
    T_FLOAT='regexp:-?(0|[1-9][0-9]*)\.[0-9]+([eE][+\-]?[0-9]+)?[a-zA-Z_]*'
    T_INT='regexp:-?(0|[1-9][0-9_]*)[a-zA-Z_]*'
    T_PREFIXED_INT='regexp:-?(0b|0x|0o|0B|0X|0O)(0|[1-9a-fA-F][0-9a-fA-F_]*)[a-zA-Z_]*'
    T_STRING_DQ="regexp:\"([^\"\\\n]|\\(\['\\\"\\\/bfnrt&]|u[0-9a-fA-F]{4}))*\""
    T_STRING_DQ_WYSIWYG='regexp:"[^"]"'
    T_STRING_SQ="regexp:'([^'\\\n]|\\(['\"\\/bfnrt&]|u[0-9a-fA-F]{4}))*'"
    T_STRING_SQ_WYSIWYG="regexp:@'[^']'"
    T_AOPEN='{'
    T_ACLOSE='}'
    T_SQOPEN='['
    T_SQCLOSE=']'
    T_DOT3='...'
    T_DOT2='..'
    T_DOT='.'
    T_COMMA=','
    T_INCREMENT='++'
    T_ADDASSIGN='+='
    T_ADD='+'
    T_DECREMENT='--'
    T_SUBASSIGN='-='
    T_SUB='-'
    T_CATASSIGN='~='
    T_CAT='~'
    T_MULASSIGN='*='
    T_MUL='*'
    T_DIVASSIGN='/='
    T_DIV='/'
    T_MODASSIGN='%='
    T_MOD='%'
    T_ORASSIGN='|='
    T_OROR='||'
    T_OR='|'
    T_ANDASSIGN='&='
    T_ANDAND='&&'
    T_AND='&'
    T_XORASSIGN='^='
    T_XOR='^'
    T_COALESCE='??'
    T_OPTCALL='?.'
    T_QUEST='?'
    T_COLON=':'
    T_BROPEN='('
    T_BRCLOSE=')'
    T_SEMICOLON=';'
    T_LESSEQ='<='
    T_SHLASSIGN='<<='
    T_SHL='<<'
    T_LESS='<'
    T_GREATEREQ='>='
    T_USHR='>>>'
    T_USHRASSIGN='>>>='
    T_SHRASSIGN='>>='
    T_SHR='>>'
    T_GREATER='>'
    T_LAMBDA='=>'
    T_EQUAL3='==='
    T_EQUAL2='=='
    T_ASSIGN='='
    T_NOTEQUAL2='!=='
    T_NOTEQUAL='!='
    T_NOT='!'
    T_DOLLAR='$'
    T_BACKTICK='`'
    K_IMPORT='import'
    K_ALIAS='alias'
    K_CLASS='class'
    K_FUNCTION='function'
    K_INTERFACE='interface'
    K_ENUM='enum'
    K_STRUCT='struct'
    K_EXPAND='expand'
    K_VARIANT='variant'
    K_ABSTRACT='abstract'
    K_FINAL='final'
    K_OVERRIDE='override'
    K_CONST='const'
    K_PRIVATE='private'
    K_PUBLIC='public'
    K_EXPORT='export'
    K_INTERNAL='internal'
    K_STATIC='static'
    K_PROTECTED='protected'
    K_IMPLICIT='implicit'
    K_VIRTUAL='virtual'
    K_EXTERN='extern'
    K_IMMUTABLE='immutable'
    K_VAL='val'
    K_VAR='var'
    K_GET='get'
    K_IMPLEMENTS='implements'
    K_SET='set'
    K_VOID='void'
    K_BOOL='bool'
    K_BYTE='byte'
    K_SBYTE='sbyte'
    K_SHORT='short'
    K_USHORT='ushort'
    K_INT='int'
    K_UINT='uint'
    K_LONG='long'
    K_ULONG='ulong'
    K_USIZE='usize'
    K_FLOAT='float'
    K_DOUBLE='double'
    K_CHAR='char'
    K_STRING='string'
    K_IF='if'
    K_ELSE='else'
    K_DO='do'
    K_WHILE='while'
    K_FOR='for'
    K_THROW='throw'
    K_PANIC='panic'
    K_LOCK='lock'
    K_TRY='try'
    K_CATCH='catch'
    K_FINALLY='finally'
    K_RETURN='return'
    K_BREAK='break'
    K_CONTINUE='continue'
    K_SWITCH='switch'
    K_CASE='case'
    K_DEFAULT='default'
    K_IN='in'
    K_IS='is'
    K_AS='as'
    K_MATCH='match'
    K_THROWS='throws'
    K_SUPER='super'
    K_THIS='this'
    K_NULL='null'
    K_TRUE='true'
    K_FALSE='false'
    K_NEW='new'
  ]
}




ZenCodeFile                          ::= (Annotation* Modifier* (Import|Definition|Statement))*;

Modifier                             ::= K_PUBLIC | K_PRIVATE | K_INTERNAL | K_EXTERN | K_ABSTRACT | K_FINAL | K_PROTECTED | K_IMPLICIT | K_VIRTUAL;
Import                               ::= K_IMPORT T_DOT? T_IDENTIFIER (T_DOT T_IDENTIFIER)* (K_AS T_IDENTIFIER)? T_SEMICOLON;
Annotation                           ::= T_SQOPEN Type AnnotationCallArguments T_SQCLOSE;
AnnotationCallArguments              ::= TypeArgumentForCall T_BROPEN Expression (T_COMMA Expression)* T_BRCLOSE
                                       | TypeArgumentForCall T_BROPEN T_BRCLOSE
                                       | TypeArgumentForCall;
TypeArgumentForCall                  ::= T_LESS Type (T_COMMA Type)* T_GREATER
                                       | ;
//Block TYPE
Type                                 ::= SingleType TypeSuffix*
private TypeSuffix                   ::= T_DOT2 Type
                                       | T_SQOPEN T_LESS Type T_GREATER T_SQCLOSE StorageTag?
                                       | T_SQOPEN Type T_SQCLOSE StorageTag?
                                       | T_SQOPEN T_COMMA* T_SQCLOSE StorageTag?
                                       | T_QUEST;
private SingleType                   ::= PrimitiveType
                                       | StoredType ;
private StoredType                   ::= (K_STRING | FunctionType | NamedType) StorageTag?;
private StorageTag                   ::= T_BACKTICK (K_STATIC | T_IDENTIFIER); //TODO: (Colon <parser.next.content>)*
private PrimitiveType                ::= K_VOID | K_BOOL | K_BYTE | K_SBYTE | K_SHORT | K_USHORT | K_INT | K_UINT | K_LONG | K_ULONG | K_USIZE | K_FLOAT | K_DOUBLE | K_CHAR;
private FunctionType                 ::= K_FUNCTION FunctionHeader;
private NamedType                    ::= T_IDENTIFIER (T_DOT T_IDENTIFIER)*;
FunctionHeader                       ::= StorageTag? TypeParameterList? T_BROPEN FunctionHeaderParameters T_BRCLOSE (K_AS Type)? (K_THROWS Type)?;
private TypeParameterList            ::= T_LESS TypeParameter (T_COMMA TypeParameter)* T_GREATER;
private TypeParameter                ::= T_IDENTIFIER (T_COLON K_SUPER? Type)*;
private FunctionHeaderParameters     ::= FunctionHeaderParameter (T_COMMA FunctionHeaderParameter)*
                                       | ;
private FunctionHeaderParameter      ::= T_IDENTIFIER T_DOT3? (K_AS Type)? (T_ASSIGN Expression)?;

//Block DEFINITION
Definition                           ::= K_CLASS DefinitionClass
                                       | K_INTERFACE DefinitionInterface
                                       | K_ENUM DefinitionEnum
                                       | K_STRUCT DefinitionStruct
                                       | K_ALIAS DefinitionAlias
                                       | K_FUNCTION DefinitionFunction
                                       | K_EXPAND DefinitionExpansion
                                       | K_VARIANT DefinitionVariant;

DefinitionClass                      ::= T_IDENTIFIER TypeParameterList? (T_COLON Type)? T_AOPEN DefinitionMember* T_ACLOSE;
DefinitionInterface                  ::= T_IDENTIFIER TypeParameterList? (T_COLON Type (T_COMMA Type)*)? T_AOPEN DefinitionMember* T_ACLOSE;
DefinitionEnum                       ::= T_IDENTIFIER (K_AS Type) T_AOPEN (ParsedEnumConstant (T_COMMA ParsedEnumConstant)*)? (T_SEMICOLON DefinitionMember*)? T_ACLOSE;
private ParsedEnumConstant           ::= T_IDENTIFIER (T_BROPEN Expression (T_COMMA Expression)* T_BRCLOSE)? (T_ASSIGN Expression)?;
DefinitionStruct                     ::= T_IDENTIFIER T_AOPEN DefinitionMember* T_ACLOSE;
DefinitionAlias                      ::= T_IDENTIFIER K_AS Type T_SEMICOLON;
DefinitionFunction                   ::= T_IDENTIFIER FunctionHeader FunctionBody;
private FunctionBody                 ::=  FunctionBodyNonEmpty | FunctionEmptyBody ;
private FunctionBodyNonEmpty         ::= FunctionLambdaBody | FunctionStatementBody;
private FunctionLambdaBody           ::= T_LAMBDA T_AOPEN Statement* T_ACLOSE
                                       | T_LAMBDA Expression;
private FunctionEmptyBody            ::= T_SEMICOLON;
private FunctionStatementBody        ::= StatementBlock;
DefinitionExpansion                  ::= TypeParameterList? Type T_AOPEN DefinitionMember* T_ACLOSE;
DefinitionVariant                    ::= T_IDENTIFIER TypeParameterList? T_AOPEN VariantOption* (T_SEMICOLON DefinitionMember*)? T_ACLOSE;
VariantOption                        ::= T_IDENTIFIER (T_BROPEN Type (T_COMMA Type)* T_BRCLOSE)?

//Block MEMBER
DefinitionMember                     ::= Annotation* DefinitionModifier* (
                                         K_VAL FieldMember
                                       | K_VAR FieldMember
                                       | K_THIS ConstructorMember
                                       | T_IDENTIFIER ConstMember
                                       | T_IDENTIFIER MethodMember
                                       | K_SET SetterMember
                                       | K_GET GetterMember
                                       | K_IMPLEMENTS ImplementationMember
                                       | T_BROPEN CallerMember
                                       | T_SQOPEN IndexMember
                                       | T_CAT K_THIS DestructorMember
                                       | Operator OperatorMember
                                       | K_AS CasterMember
                                       | (K_CLASS | K_INTERFACE | K_ALIAS | K_STRUCT | K_ENUM) InnerDefinitionMember
                                       | K_FOR IteratorMember
                                       | T_AOPEN StaticInitializerMember
                                     );


Operator                             ::= T_ADD | T_SUB | T_MUL | T_DIV | T_MOD | T_AND | T_OR | T_XOR | T_NOT | T_ADDASSIGN | T_SUBASSIGN | T_CATASSIGN | T_MULASSIGN | T_DIVASSIGN | T_MODASSIGN | T_ANDASSIGN | T_ORASSIGN | T_XORASSIGN | T_INCREMENT | T_DECREMENT | T_DOT2 | T_SHL | T_SHR | T_USHR | T_SHLASSIGN | T_SHRASSIGN | T_USHRASSIGN | T_CAT
                                       | T_EQUAL2 | K_IN
private DefinitionModifier           ::= K_INTERNAL | K_PUBLIC | K_PRIVATE | K_CONST | K_ABSTRACT | K_FINAL | K_STATIC | K_PROTECTED | K_IMPLICIT | K_EXTERN | K_OVERRIDE;
private FieldMember                  ::= T_IDENTIFIER (K_AS Type)? (T_COLON FieldAutoProp)? (T_ASSIGN Expression)? T_SEMICOLON;
private FieldAutoProp                ::= (K_PUBLIC | K_PRIVATE)? (K_GET | K_SET) (T_COMMA FieldAutoProp)?;
private ConstructorMember            ::= FunctionHeader FunctionBodyNonEmpty;
private ConstMember                  ::= (K_AS Type)? T_ASSIGN Expression T_SEMICOLON;
private MethodMember                 ::= FunctionHeader FunctionBody;
private SetterMember                 ::= T_IDENTIFIER (K_AS Type)? FunctionBody;
private GetterMember                 ::= T_IDENTIFIER (K_AS Type)? FunctionBody;
private ImplementationMember         ::= Type T_SEMICOLON
                                       | Type T_AOPEN DefinitionMember* T_ACLOSE;
private CallerMember                 ::= FunctionHeader FunctionBody;
private IndexMember                  ::= T_SQCLOSE T_ASSIGN? FunctionHeader FunctionBody;
private DestructorMember             ::= FunctionBody;
private OperatorMember               ::= FunctionHeader FunctionBody;
private CasterMember                 ::= Type FunctionBody;
private InnerDefinitionMember        ::= Definition;
private IteratorMember               ::= FunctionHeader FunctionBody;
private StaticInitializerMember      ::= StatementBlock;


//Block STATEMENT
Statement                            ::= T_AOPEN StatementBlock
                                       | K_RETURN StatementReturn
                                       | K_VAR StatementVar
                                       | K_VAL StatementVar
                                       | K_IF StatementIf
                                       | K_FOR StatementFor
                                       | K_DO StatementDoWhile
                                       | K_WHILE StatementWhile
                                       | K_LOCK StatementLock
                                       | K_THROW StatementThrow
                                       | K_TRY StatementTryCatch
                                       | K_CONTINUE StatementContinue
                                       | K_BREAK StatementBreak
                                       | K_SWITCH StatementSwitch
                                       | StatementExpression;
StatementBlock                       ::= Statement* T_ACLOSE;
StatementReturn                      ::= Expression? T_SEMICOLON;
StatementVar                         ::= T_IDENTIFIER (K_AS Type)? (T_ASSIGN Expression)? T_SEMICOLON {implements="com.intellij.psi.PsiNameIdentifierOwner" methods=[getName setName getNameIdentifier]};
StatementIf                          ::= Expression Statement (K_ELSE Statement)?;
StatementFor                         ::= T_IDENTIFIER (T_COMMA T_IDENTIFIER)* K_IN Expression Statement;
StatementDoWhile                     ::= (T_COLON T_IDENTIFIER)? Statement K_WHILE Expression T_SEMICOLON;
StatementWhile                       ::= (T_COLON T_IDENTIFIER)? Expression Statement;
StatementLock                        ::= Expression Statement;
StatementThrow                       ::= Expression T_SEMICOLON;
StatementTryCatch                    ::= (T_IDENTIFIER T_ASSIGN Expression)? Statement CatchClause* (K_FINALLY Statement)?
private CatchClause                  ::= K_CATCH T_IDENTIFIER? (K_AS Type) Statement;
StatementContinue                    ::= T_IDENTIFIER? T_SEMICOLON;
StatementBreak                       ::= T_IDENTIFIER? T_SEMICOLON;
StatementSwitch                      ::= (T_COLON T_IDENTIFIER)? T_AOPEN SwitchCase* T_ACLOSE;
private SwitchCase                   ::= (K_CASE Expression | K_DEFAULT) T_COLON Statement*;
StatementExpression                  ::= Expression T_SEMICOLON;



//Block EXPRESSION
Expression                           ::= ExpressionAssign;
ExpressionAssign                     ::= ConditionalExpression ((T_ASSIGN | AssignOperator) ExpressionAssign)?;
private AssignOperator               ::= T_ADDASSIGN | T_SUBASSIGN | T_CATASSIGN | T_MULASSIGN | T_DIVASSIGN | T_MODASSIGN | T_ORASSIGN | T_ANDASSIGN | T_XORASSIGN | T_SHLASSIGN | T_SHRASSIGN | T_USHRASSIGN;
ConditionalExpression                ::= ExpressionOrOr (T_QUEST ExpressionOrOr T_COLON ConditionalExpression)?;
ExpressionOrOr                       ::= ExpressionAndAnd (T_OROR ExpressionAndAnd)* (T_COALESCE ExpressionAndAnd)*;
ExpressionAndAnd                     ::= ExpressionOr (T_ANDAND ExpressionOr)*;
ExpressionOr                         ::= ExpressionXor (T_OR ExpressionXor)*;
ExpressionXor                        ::= ExpressionAnd (T_XOR ExpressionAnd)*;
ExpressionAnd                        ::= ExpressionCompare (T_AND ExpressionCompare)*;
ExpressionCompare                    ::= ExpressionShift (T_NOT)? K_IS Type
                                       | ExpressionShift T_NOT K_IN ExpressionShift
                                       | ExpressionShift (CompareOperator ExpressionShift)?;
private CompareOperator              ::= T_EQUAL2 | T_EQUAL3 | T_NOTEQUAL | T_NOTEQUAL2 | T_LESS | T_LESSEQ | T_GREATER | T_GREATEREQ | K_IN;
ExpressionShift                      ::= ExpressionAdd (ShiftOperator ExpressionAdd)*;
private ShiftOperator                ::= T_SHL | T_SHR | T_USHR;
ExpressionAdd                        ::= ExpressionMul (AddOperator ExpressionMul)*
private AddOperator                  ::= T_ADD | T_SUB | T_CAT;
ExpressionMul                        ::= ExpressionUnary (MulOperator ExpressionUnary)*
private MulOperator                  ::= T_MUL | T_DIV | T_MOD;
ExpressionUnary                      ::= UnaryOperator ExpressionUnary
                                       | K_TRY T_QUEST ExpressionTryConvert
                                       | K_TRY T_NOT ExpressionRethrow
                                       | ExpressionPostFix;
private UnaryOperator                ::= T_NOT | T_SUB | T_CAT | T_INCREMENT | T_DECREMENT;
private ExpressionTryConvert         ::= ExpressionUnary;
private ExpressionRethrow            ::= ExpressionUnary;
ExpressionPostFix                    ::= ExpressionPrimary PostFix*;
private PostFix                      ::= PostFixMemberGet
                                       | PostFixOuter
                                       | PostFixRange
                                       | PostFixIndex
                                       | PostFixCall
                                       | PostFixCast
                                       | PostFixIncrement
                                       | PostFixDecrement
                                       | PostFixLambda;
private PostFixMemberGet            ::= T_DOT (T_IDENTIFIER | T_STRING_SQ | T_STRING_DQ);
private PostFixOuter                ::= T_DOT T_DOLLAR;
private PostFixRange                ::= T_DOT2 ExpressionAssign;
private PostFixIndex                ::= T_SQOPEN ExpressionAssign (T_COMMA ExpressionAssign)* T_SQCLOSE;
private PostFixCall                 ::= T_BROPEN (ExpressionAssign (T_COMMA ExpressionAssign)*)? T_BRCLOSE;
private PostFixCast                 ::= K_AS (T_QUEST)? Type;
private PostFixIncrement            ::= T_INCREMENT;
private PostFixDecrement            ::= T_DECREMENT;
private PostFixLambda               ::= FunctionLambdaBody;
ExpressionPrimary                   ::= ExpressionLiteral
                                      | ExpressionVariable
                                      | ExpressionLocalVariable
                                      | ExpressionThis
                                      | ExpressionSuper
                                      | ExpressionDollar
                                      | ExpressionArray
                                      | ExpressionMap
                                      | ExpressionBool
                                      | ExpressionNull
                                      | ExpressionBracketed
                                      | ExpressionNew
                                      | ExpressionThrow
                                      | ExpressionPanic
                                      | ExpressionMatch
                                      | ExpressionBracketHandler
                                      | Type;
private ExpressionLiteral           ::= ExpressionInt
                                      | ExpressionFloat
                                      | ExpressionString;
private ExpressionInt               ::= T_INT | T_PREFIXED_INT;
private ExpressionFloat             ::= T_FLOAT
private ExpressionString            ::= T_STRING_SQ | T_STRING_DQ;
ExpressionVariable                  ::= T_IDENTIFIER;
private ExpressionLocalVariable     ::= T_LOCAL_IDENTIFIER;
private ExpressionThis              ::= K_THIS;
private ExpressionSuper             ::= K_SUPER;
private ExpressionDollar            ::= T_DOLLAR;
private ExpressionArray             ::= T_SQOPEN (ExpressionAssign (T_COMMA ExpressionAssign)*)? T_SQCLOSE;
private ExpressionMap               ::= T_AOPEN (MapEntry (T_COMMA MapEntry)*)? T_ACLOSE;
private MapEntry                    ::= ExpressionAssign (T_COLON ExpressionAssign)?;
private ExpressionBool              ::= K_TRUE | K_FALSE;
private ExpressionNull              ::= K_NULL;
private ExpressionNew               ::= K_NEW Type (TypeArgumentForCall? T_BROPEN (Expression (T_COMMA Expression)*)? T_BRCLOSE)?;
private ExpressionThrow             ::= K_THROW Expression;
private ExpressionPanic             ::= K_PANIC Expression;
private ExpressionMatch             ::= K_MATCH Expression T_AOPEN (MatchClause (T_COMMA MatchClause)*)? T_ACLOSE;
private MatchClause                 ::= (K_DEFAULT | Expression) T_LAMBDA Expression;
ExpressionBracketHandler            ::= T_LESS ValidBracketContent* T_GREATER;
//FIXME
private ValidBracketContent         ::= T_IDENTIFIER
                                      | T_COLON
                                      | T_SEMICOLON
                                      | T_INT
                                      | T_FLOAT
                                      | T_STRING_DQ
                                      | T_DOLLAR (T_AOPEN Expression T_ACLOSE)?;
ExpressionBracketed                 ::= T_BROPEN (ExpressionAssign (T_COMMA ExpressionAssign)* T_COMMA?)? T_BRCLOSE;